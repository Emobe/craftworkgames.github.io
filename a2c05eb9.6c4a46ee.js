(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{74:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"rightToc",(function(){return p})),n.d(t,"default",(function(){return l}));var a=n(2),i=n(6),r=(n(0),n(88)),o={id:"entities",title:"Entities",sidebar_label:"Entities"},s={unversionedId:"features/entities/entities",id:"features/entities/entities",isDocsHomePage:!1,title:"Entities",description:"The Entities package is a modern high performance Artemis based Entity Component System. Many of the features found in this implementation were inspired by artemis-odb. Although, many others were also studied during development. As you'll see the systems are designed to feel familar to MonoGame developers.",source:"@site/docs\\features\\entities\\entities.md",slug:"/features/entities/entities",permalink:"/docs/features/entities/entities",editUrl:"https://github.com/craftworkgames/craftworkgames.github.io/tree/develop/docs/features/entities/entities.md",version:"current",sidebar_label:"Entities",sidebar:"docs",previous:{title:"Graphics",permalink:"/docs/features/graphics/graphics"},next:{title:"Collections",permalink:"/docs/features/collections/collections"}},p=[{value:"Installation",id:"installation",children:[]},{value:"What is an ECS?",id:"what-is-an-ecs",children:[{value:"Components",id:"components",children:[]},{value:"Entities",id:"entities",children:[]},{value:"Systems",id:"systems",children:[]}]},{value:"Creating the world",id:"creating-the-world",children:[]},{value:"Creating entities",id:"creating-entities",children:[]},{value:"Destroying entities",id:"destroying-entities",children:[]},{value:"Types of systems",id:"types-of-systems",children:[]},{value:"Creating systems",id:"creating-systems",children:[]},{value:"Accessing components",id:"accessing-components",children:[]},{value:"Filtering components",id:"filtering-components",children:[]},{value:"Example",id:"example",children:[]}],c={rightToc:p};function l(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(r.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(r.b)("p",null,"The Entities package is a modern high performance Artemis based Entity Component System. Many of the features found in this implementation were inspired by artemis-odb. Although, many others were also studied during development. As you'll see the systems are designed to feel familar to MonoGame developers."),Object(r.b)("h2",{id:"installation"},"Installation"),Object(r.b)("p",null,Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.nuget.org/packages/MonoGame.Extended.Entities"}),"MonoGame.Extended.Entities")," is distributed via a NuGet package. You can add the NuGet package to your C# project through your IDE of choice (Visual Studio, Xamarin Studio, Rider, etc) or through the Command Line Interface (CLI) using the dotnet command."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{}),"dotnet add MonoGame.Extended.Entities\n")),Object(r.b)("h2",{id:"what-is-an-ecs"},"What is an ECS?"),Object(r.b)("p",null,"An ",Object(r.b)("a",Object(a.a)({parentName:"p"},{href:"https://www.gamedev.net/articles/programming/general-and-gameplay-programming/understanding-component-entity-systems-r3013"}),"Entity Component System (ECS)")," is a way to build and manage the entities (or game objects) in your game by composing their component parts together. An ECS consists of three main parts:"),Object(r.b)("h3",{id:"components"},"Components"),Object(r.b)("p",null,"A component is simply a class that holds some state about the entity. Typically, components are lightweight and don't contain any game logic. It's common to have components with only a few properties or fields. Components can be more complex but inheritence is not encouraged."),Object(r.b)("h3",{id:"entities"},"Entities"),Object(r.b)("p",null,"An entity is a composition of components identified by an ID. Often you only need the ID of the entity to work with it. For performance reasons, and entity ID is only valid while the entity is alive. Once the entity is destroyed, it's ID may be recycled."),Object(r.b)("h3",{id:"systems"},"Systems"),Object(r.b)("p",null,"A system is a class that will run during the game's ",Object(r.b)("inlineCode",{parentName:"p"},"Update")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Draw")," calls. They usually contain the game logic about how to manage a filtered collection of entities and their components. "),Object(r.b)("h2",{id:"creating-the-world"},"Creating the world"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"World")," is the entry point to the ECS. It holds your entities and systems and you'll use it later to create and destroy entities."),Object(r.b)("p",null,"To create the world you need to use the ",Object(r.b)("inlineCode",{parentName:"p"},"WorldBuilder")," and add your systems before building the ",Object(r.b)("inlineCode",{parentName:"p"},"World")," instance."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"_world = new WorldBuilder()\n    .AddSystem(new PlayerSystem())\n    .AddSystem(new RenderSystem(GraphicsDevice))\n    .Build();\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note:")," Manually adding your systems this way might seem annoying at first, but it can be highly desireable to be able to control the order systems are added. It also allows you to constructor inject services as desired."),Object(r.b)("p",null,"Once the world is created you need to call the ",Object(r.b)("inlineCode",{parentName:"p"},"Update")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Draw")," methods. "),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"protected override void Update(GameTime gameTime)\n{\n    _world.Update(gameTime);\n    base.Update(gameTime);\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"protected override void Draw(GameTime gameTime)\n{\n    _world.Draw(gameTime);\n    base.Draw(gameTime);\n}\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note:")," The world also implements the ",Object(r.b)("inlineCode",{parentName:"p"},"IGameComponent")," interface, so if you prefer you can add it to the ",Object(r.b)("inlineCode",{parentName:"p"},"GameComponentCollection")," instead (not to be confused with ECS components)."),Object(r.b)("h2",{id:"creating-entities"},"Creating entities"),Object(r.b)("p",null,"Usually when you create an entity you'll want to attach some components to it immediately. This is not required though, as components can be added and removed anytime by systems."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var entity = _world.CreateEntity();\nentity.Attach(new Transform2(position));\nentity.Attach(new Sprite(textureRegion));\n")),Object(r.b)("p",null,"Any standard class can be used as a component but typically you'll want to keep your components lightweight and specific."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note:")," An entity can only have one instance of each component type."),Object(r.b)("h2",{id:"destroying-entities"},"Destroying entities"),Object(r.b)("p",null,"Removing entities from the world is easy."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"_world.DestroyEntity(entity);\n")),Object(r.b)("p",null,"It should be noted that the actual entity creation and removal is deferred until the next update. This allows for some performance optimizations and batches events so that they can be handled more gracefully by systems."),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note:")," When you're inside an ",Object(r.b)("inlineCode",{parentName:"p"},"EntitySystem")," there are helper methods for creating destroying entities so that you don't need to access the ",Object(r.b)("inlineCode",{parentName:"p"},"World")," instance each time."),Object(r.b)("h2",{id:"types-of-systems"},"Types of systems"),Object(r.b)("p",null,"Systems can be used to do all kinds of processing during your game. There are several kinds of base systems available to build your game."),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},"An ",Object(r.b)("inlineCode",{parentName:"li"},"UpdateSystem")," is a basic system that has an ",Object(r.b)("inlineCode",{parentName:"li"},"Update")," method called every frame."),Object(r.b)("li",{parentName:"ul"},"A ",Object(r.b)("inlineCode",{parentName:"li"},"DrawSystem")," is a basic system that has a ",Object(r.b)("inlineCode",{parentName:"li"},"Draw")," method called every frame."),Object(r.b)("li",{parentName:"ul"},"An ",Object(r.b)("inlineCode",{parentName:"li"},"EntityUpdateSystem")," is used to process a filtered collection of entities during the ",Object(r.b)("inlineCode",{parentName:"li"},"Update")," call."),Object(r.b)("li",{parentName:"ul"},"An ",Object(r.b)("inlineCode",{parentName:"li"},"EntityDrawSystem")," is used to process a filtered collection of entities during the ",Object(r.b)("inlineCode",{parentName:"li"},"Draw")," call."),Object(r.b)("li",{parentName:"ul"},"An ",Object(r.b)("inlineCode",{parentName:"li"},"EntityProcessingSystem")," can be used to process a filtered collection of entities one at a time during the ",Object(r.b)("inlineCode",{parentName:"li"},"Update")," call. "),Object(r.b)("li",{parentName:"ul"},"You can also create a system that has both an ",Object(r.b)("inlineCode",{parentName:"li"},"Update")," method and a ",Object(r.b)("inlineCode",{parentName:"li"},"Draw")," method by implementing the ",Object(r.b)("inlineCode",{parentName:"li"},"IUpdateSystem")," and ",Object(r.b)("inlineCode",{parentName:"li"},"IDrawSystem")," interfaces respectively."),Object(r.b)("li",{parentName:"ul"},"An ",Object(r.b)("inlineCode",{parentName:"li"},"EntitySystem")," is the base class for all entity processing systems. Typically you won't derive from this class unless you're building a new type of entity processing system. If you do derive from this class you probably also want to implement one of the update or draw interfaces.")),Object(r.b)("h2",{id:"creating-systems"},"Creating systems"),Object(r.b)("p",null,"To create a new system, decide which base system to derive from and implement a new class."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"public class RenderSystem : EntityDrawSystem\n")),Object(r.b)("p",null,"When you're creating entity systems the first thing you'll want to do is provide an ",Object(r.b)("inlineCode",{parentName:"p"},"Aspect")," to filter the system to only process the entities you're interested in."),Object(r.b)("p",null,"For example, a typical ",Object(r.b)("inlineCode",{parentName:"p"},"RenderSystem")," might want to process entities with a ",Object(r.b)("inlineCode",{parentName:"p"},"Sprite")," component and a ",Object(r.b)("inlineCode",{parentName:"p"},"Transform2")," component. To provide an aspect you pass it into the base constructor."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"public RenderSystem(GraphicsDevice graphicsDevice)\n    : base(Aspect.All(typeof(Sprite), typeof(Transform2)))\n{\n    _graphicsDevice = graphicsDevice;\n    _spriteBatch = new SpriteBatch(graphicsDevice);\n}\n")),Object(r.b)("p",null,"Next, you'll need to override the ",Object(r.b)("inlineCode",{parentName:"p"},"Update")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Draw")," method (depending on what type of system you're implementing)."),Object(r.b)("p",null,"In our case, the ",Object(r.b)("inlineCode",{parentName:"p"},"Draw")," method might look something like this:"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"public override void Draw(GameTime gameTime)\n{\n    _spriteBatch.Begin();\n\n    foreach (var entity in ActiveEntities)\n    {\n      // draw your entities\n    }\n\n    _spriteBatch.End();\n}\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note:")," Don't forget to add your system to the ",Object(r.b)("inlineCode",{parentName:"p"},"WorldBuilder")," when you're done."),Object(r.b)("h2",{id:"accessing-components"},"Accessing components"),Object(r.b)("p",null,"The preferred way to access components is to use component mappers."),Object(r.b)("p",null,"A ",Object(r.b)("inlineCode",{parentName:"p"},"ComponentMapper")," provides a very fast way to access components within a system. When you're using a component mapper you're getting nearly direct access to the underlying arrays that hold the components under the hood."),Object(r.b)("p",null,"To get a component mapper, create a field on your system and use the ",Object(r.b)("inlineCode",{parentName:"p"},"Initialize")," method to grab an instance of the mapper. Do this for each component type you want to process."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"public override void Initialize(IComponentMapperService mapperService)\n{\n  _transformMapper = mapperService.GetMapper<Transform2>();\n  _spriteMapper = mapperService.GetMapper<Sprite>();\n}\n")),Object(r.b)("p",null,"Then inside the ",Object(r.b)("inlineCode",{parentName:"p"},"Update")," or ",Object(r.b)("inlineCode",{parentName:"p"},"Draw")," method you can get access to the components for each entity you want to process."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var transform = _transformMapper.Get(entityId);\nvar sprite = _spriteMapper.Get(entityId);\n\n_spriteBatch.Draw(sprite, transform);\n")),Object(r.b)("p",null,"Component mappers can also be used to modify entities on the fly. For example, you can add a new component to an entity with the ",Object(r.b)("inlineCode",{parentName:"p"},"Put")," method."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"_buffMapper.Put(entityId, buffComponent);\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note:")," The ",Object(r.b)("inlineCode",{parentName:"p"},"Put")," method will replace an existing component of the same type if it already exists. There is no need to check if the entity already has the component."),Object(r.b)("p",null,"You can also check if an entity ",Object(r.b)("inlineCode",{parentName:"p"},"Has")," a component or ",Object(r.b)("inlineCode",{parentName:"p"},"Delete")," a component with the mapper."),Object(r.b)("hr",null),Object(r.b)("p",null,"For convienience it's also possible to access components on an entity ",Object(r.b)("em",{parentName:"p"},"without")," using component mappers. This can be useful for prototyping ideas or when performance isn't a primary concern."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-csharp"}),"var entity = GetEntity(entityId);\nvar health = entity.Get<HealthComponent>();\nvar transform = entity.Get<Transform2>();\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"Note:")," This method of accessing components requires dictionary lookups of the component types each frame. This is still a fairly fast operation, and for some games it'll do just fine."),Object(r.b)("h2",{id:"filtering-components"},"Filtering components"),Object(r.b)("p",null,"An ",Object(r.b)("inlineCode",{parentName:"p"},"Aspect")," is used by entity systems to decide what component types the system will process. The entities will be available in the system's ",Object(r.b)("inlineCode",{parentName:"p"},"ActiveEntities")," collection."),Object(r.b)("p",null,"An aspect has three methods:"),Object(r.b)("ul",null,Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Aspect.All(A, B)")," requires the entities to have all of the desired components."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Aspect.One(C, D)")," requires the entities to have any one or more of the components."),Object(r.b)("li",{parentName:"ul"},Object(r.b)("inlineCode",{parentName:"li"},"Aspect.Exclude(E, F)")," will exclude entities that have any of these components.")),Object(r.b)("p",null,"Aspects can also be chained together. For example, an entity matching:"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"Aspect.All(A, B).One(C, D).Exclude(E)")," would need to have A and B and at least one of C or D except if it has E."),Object(r.b)("h2",{id:"example"},"Example"),Object(r.b)("p",null,"In this example we are going to make a rain simulator."),Object(r.b)("p",null,"We start by including the ",Object(r.b)("inlineCode",{parentName:"p"},"Entities")," namespaces."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cs"}),"using MonoGame.Extended.Entities;\n")),Object(r.b)("p",null,"Next, we create our ",Object(r.b)("inlineCode",{parentName:"p"},"Expiry")," and ",Object(r.b)("inlineCode",{parentName:"p"},"Raindrop")," components."),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cs"}),"public class Expiry\n{\n    public Expiry(float timeRemaining)\n    {\n        TimeRemaining = timeRemaining;\n    }\n\n    public float TimeRemaining;\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cs"}),"public class Raindrop\n{\n    public Vector2 Velocity;\n    public float Size = 3;\n}\n")),Object(r.b)("p",null,"Then we define our systems"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cs"}),"public class ExpirySystem : EntityProcessingSystem\n{\n    private ComponentMapper<Expiry> _expiryMapper;\n\n    public ExpirySystem() \n        : base(Aspect.All(typeof(Expiry)))\n    {\n    }\n\n    public override void Initialize(IComponentMapperService mapperService)\n    {\n        _expiryMapper = mapperService.GetMapper<Expiry>();\n    }\n\n    public override void Process(GameTime gameTime, int entityId)\n    {\n        var expiry = _expiryMapper.Get(entityId);\n        expiry.TimeRemaining -= gameTime.GetElapsedSeconds();\n        if (expiry.TimeRemaining <= 0)\n            DestroyEntity(entityId);\n    }\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cs"}),"public class RainfallSystem : EntityUpdateSystem\n{\n    private readonly FastRandom _random = new FastRandom();\n    private ComponentMapper<Transform2> _transformMapper;\n    private ComponentMapper<Raindrop> _raindropMapper;\n    private ComponentMapper<Expiry> _expiryMapper;\n\n    private const float MinSpawnDelay = 0.0f;\n    private const float MaxSpawnDelay = 0.0f;\n    private float _spawnDelay = MaxSpawnDelay;\n\n    public RainfallSystem()\n        : base(Aspect.All(typeof(Transform2), typeof(Raindrop)))\n    {\n    }\n\n    public override void Initialize(IComponentMapperService mapperService)\n    {\n        _transformMapper = mapperService.GetMapper<Transform2>();\n        _raindropMapper = mapperService.GetMapper<Raindrop>();\n        _expiryMapper = mapperService.GetMapper<Expiry>();\n    }\n\n    public override void Update(GameTime gameTime)\n    {\n        var elapsedSeconds = gameTime.GetElapsedSeconds();\n\n        foreach (var entityId in ActiveEntities)\n        {\n            var transform = _transformMapper.Get(entityId);\n            var raindrop = _raindropMapper.Get(entityId);\n\n            raindrop.Velocity += new Vector2(0, 500) * elapsedSeconds;\n            transform.Position += raindrop.Velocity * elapsedSeconds;\n\n            if (transform.Position.Y >= 480 && !_expiryMapper.Has(entityId))\n            {\n                for (var i = 0; i < 3; i++)\n                {\n                    var velocity = new Vector2(_random.NextSingle(-100, 100), -raindrop.Velocity.Y * _random.NextSingle(0.1f, 0.2f));\n                    var id = CreateRaindrop(transform.Position.SetY(479), velocity, (i + 1) * 0.5f);\n                    _expiryMapper.Put(id, new Expiry(1f));\n                }\n\n                DestroyEntity(entityId);\n            }\n        }\n\n        _spawnDelay -= gameTime.GetElapsedSeconds();\n\n        if (_spawnDelay <= 0)\n        {\n            for (var q = 0; q < 50; q++)\n            {\n                var position = new Vector2(_random.NextSingle(0, 800), _random.NextSingle(-240, -480));\n                CreateRaindrop(position);\n            }\n            _spawnDelay = _random.NextSingle(MinSpawnDelay, MaxSpawnDelay);\n        }\n    }\n\n    private int CreateRaindrop(Vector2 position, Vector2 velocity = default(Vector2), float size = 3)\n    {\n        var entity = CreateEntity();\n        entity.Attach(new Transform2(position));\n        entity.Attach(new Raindrop { Velocity = velocity, Size = size });\n        return entity.Id;\n    }\n}\n")),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cs"}),"public class RenderSystem : EntityDrawSystem\n{\n    private readonly GraphicsDevice _graphicsDevice;\n    private readonly SpriteBatch _spriteBatch;\n\n    private ComponentMapper<Transform2> _transformMapper;\n    private ComponentMapper<Raindrop> _raindropMapper;\n    \n    public RenderSystem(GraphicsDevice graphicsDevice)\n        : base(Aspect.All(typeof(Transform2), typeof(Raindrop)))\n    {\n        _graphicsDevice = graphicsDevice;\n        _spriteBatch = new SpriteBatch(graphicsDevice);\n    }\n\n    public override void Initialize(IComponentMapperService mapperService)\n    {\n        _transformMapper = mapperService.GetMapper<Transform2>();\n        _raindropMapper = mapperService.GetMapper<Raindrop>();\n    }\n\n    public override void Draw(GameTime gameTime)\n    {\n        _graphicsDevice.Clear(Color.DarkBlue * 0.2f);\n        _spriteBatch.Begin(samplerState: SamplerState.PointClamp);\n\n        foreach (var entity in ActiveEntities)\n        {\n            var transform = _transformMapper.Get(entity);\n            var raindrop = _raindropMapper.Get(entity);\n\n            _spriteBatch.FillRectangle(transform.Position, new Size2(raindrop.Size, raindrop.Size), Color.LightBlue);\n        }\n        _spriteBatch.End();\n    }\n}\n")),Object(r.b)("p",null,"And last but not least, we merge everything into the game's initialize function"),Object(r.b)("pre",null,Object(r.b)("code",Object(a.a)({parentName:"pre"},{className:"language-cs"}),"_world = new WorldBuilder()\n    .AddSystem(new RainfallSystem())\n    .AddSystem(new ExpirySystem())\n    .AddSystem(new RenderSystem(GraphicsDevice))\n    .Build();\nComponents.Add(_world);\n")))}l.isMDXComponent=!0},88:function(e,t,n){"use strict";n.d(t,"a",(function(){return m})),n.d(t,"b",(function(){return u}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),l=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},m=function(e){var t=l(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,c=p(e,["components","mdxType","originalType","parentName"]),m=l(n),b=a,u=m["".concat(o,".").concat(b)]||m[b]||d[b]||r;return n?i.a.createElement(u,s(s({ref:t},c),{},{components:n})):i.a.createElement(u,s({ref:t},c))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=b;var s={};for(var p in t)hasOwnProperty.call(t,p)&&(s[p]=t[p]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"}}]);